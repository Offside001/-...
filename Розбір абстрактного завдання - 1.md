#### 1 блок

1. *Відобрази агрегуючі показники (середнє, максимум та мінімум) для щоденних витрат по Google та Facebook окремо.*
	
	* "для щоденних витрат". Оскільки витрати - це `spend`, мені потрібно зробити вибірку spend, а в from вказати `facebook_ads_basic_daily` та `google_ads_basic_daily`.  Звісно, треба додати `ad_date` і згрупувати по ньому, адже звідки ж ще ми візьмемо "для щоденних витрат"; можна додати `media_source`, щоб визначати джерела трафіку.
	
	* Ці джерела треба поєднати. Мабуть, треба робити CTE з ними, а вже з тієї CTE зробити min(), max(), avg().

2. *Знайди топ-5 днів за рівнем ROMI загалом (включаючи_ Google та Facebook), виведи дати та відповідні значення в порядку спадання.*
	
	* Очевидно, потрібно зробити вибірку з обчисленим ROMI, яку можна зробити з CTE, в якій додамо базові сирі дані, а вже з них у запиті до CTE порахуємо саме ROMI.
	
	* "Знайди топ-5 днів за рівнем ROMI загалом". Мабуть треба буде створити поле `ad_date`, видобути з даної колонки (`extract()`) поденний розрахунок (`day`), згрупувати цей ROMI по днях, а потім просто зробити `order by ROMI desc`; мені виведе найбільший ROMI, із яких я просто зроблю `limit 5`, отримавши 5 днів з найбільшими ROMI.

3. *Відобрази компанію з найвищим рівнем загального тижневого value (не забудь вказати тиждень та значення рекорду).*
	
	* "Відобрази компанію з найвищим рівнем загального тижневого value". Ймовірно, це завдання схоже з попереднім: мені потрібно вивести `campaign_name`, помістити її в `group by` разом з `ad_date`, перетворивши її в `week` за допомогою того ж `extract` або `DATE_TRUNC` і по відношенню до цього всього зробити `sum(value)` (порахувати конверсію).
	
	* "не забудь вказати тиждень та значення рекорду". Це означає показати запис, у якому був найбільший `SUM(value)` за тиждень. У мене буде таблиця з `campaign_id`, `week`, `total_value`. З неї треба вибрати запис з найбільшим `total_value` через `ORDER BY total_value DESC LIMIT 1`.
	
	* Для виконання цього завдання потрібно почати з двох базових CTE: 1. Зробити вибірку з `facebook_ads_basic_daily`, до якого приєднати `campaign_id` з `facebook_campaign`, щоб отримати `campaign_name`, а також обрати інші сирі дані. 2. Зробити вибірку з `google_ads_basic_daily`+ сирі дані, без особливостей. Наступним кроком буде створити третю CTE, де за допомогою union all об'єднати попередні таблиці. В кінцевій вибірці потрібно вже розрахувати фінальні показники.

4. *Знайди кампанію, що мала найбільший приріст у охопленні місяць-до місяця.*

	* Можливо, мені потрібно порівняти `impression` останній місяць з його попереднім? Якщо так, треба знову включити у вибірку `ad_date`, витягти з неї  `month`, прописати `campaign_name` (`campaign_name` треба буде додати до джерела facebook через join з іншої таблиці), і по відношенню до обох показників розрахувати через `sum` наш `impression`. Далі поточний розрахований `impression` потрібно відняти від `lag(impression)` (попереднього), і поділити знову на `lag(impression)`. Обов'язково в `partition by` вказати по відношенню до `campaign_name`, а `order by` - по `ad_date`.  Якось за таким сценарієм, мабуть, має виконуватися цей пункт завдання.

5. *Напиши запит, який поверне назву та тривалість найдовшого безперервного (щоденного) показу `adset_name` (разом з Google та Facebook). (виконання цього підзавдання не обовʼязкове, за бажанням)**.*
	* Це **найскладніше** завдання, адже воно про **послідовність днів**, а не просто групування. Ймовірно, треба для кожного `adset_name`, знайти всі `ad_date`, коли воно було активне. Визначити безперервні діапазони днів. Це складно.
	
	* **"Безперервний (щоденний) показ"** означає, що якась реклама (`adset_name`) показувалась щодня без пропусків. Тобто треба знайти якусь послідовність днів, у якій `adset_name` **безперервно була активна** кожного дня, жодного не пропускаючи. Потрібно знайти `adset_name`, у якого така послідовність найдовша, і вивести назву `adset_name` й тривалість цієї безперервної послідовності (в днях). Що для цього робити:
	
		* Обрати `adset_name`, `ad_date`, об'єднати Facebook та Google дані (`facebook_ads_basic_daily`, `google_ads_basic_daily`)
		
		- За допомогою `join` Приєднати `adset_name` до основної таблиці facebook: `join facebook_adset on facebook_ads_basic_daily.adset_id = facebook_adset.adset_id`. 
		
		- Можлива логіка подальшого розв'язання:
		
			- **CTE `merged_data`** - об'єднує `ad_date` та `adset_name` з обох джерел.
    
			- **CTE `step_2_row_number`** - нумерує рядки для кожного `adset_name` в порядку зростання дати (`ROW_NUMBER()`).
    
			- **CTE `step_3_group`**: додає колонку `ad_date - ROW_NUMBER()` - якщо різниця стала іншою, значить почалась нова група (серія днів без пропуску)
    
			- **CTE `lenght_search`**: обчислює кількість днів у кожній такій серії (`COUNT(*) GROUP BY adset_name, group_row_adset_name`)
    
			- **Фінальний SELECT**: вибирає `adset_name` з максимальною довжиною безперервної серії


#### 2 блок

1. *Створи запит для отримання таблиці з інформацією про події, користувачів та сесії в GA4. В результаті виконання запиту ми маємо отримати таблицю, що міститиме такі поля:*

	- event_timestamp — дата та час події (тип даних має бути timestamp)
	- user_pseudo_id — анонімний ідентифікатор користувача в GA4
	- session_id — ідентифікатор сесії подій в GA4
	- event_name — назва події
	- country — країна користувача сайту
	- device_category — категорія пристрою користувача сайту
	- source — джерело відвідування сайту
	- medium — medium відвідування сайту
	- campaign — назва кампанії відвідування сайту

2. Таблиця має включати лише дані за 2021 рік і таких подій:

	- Початок сесії на сайті
	- Перегляд товару
	- Додавання товару до корзини
	- Подія початку оформлення замовлення
	- Додавання інформації про доставку
	- Додавання платіжної інформації
	- Покупка

**Можливе розв'язання:**

1. Для початку виводимо сирі показники, як написано в завданні: 
	* user_pseudo_id
	* session_id
	* event_name
	* Щодо `event_timestamp`, там потрібно конвертувати цю дату в класичний вигляд шляхом використання команди `timestamp_micros(event_timestamp)`.
	* `country` Знаходиться в розділі `geo`. Треба буде посилатися через `geo.country`
	* `device_category` те ж саме, звертатися як `device.category`.
	* `source`, `medium` і campaign (насправді `name`, я не розумію, чому вони назвали "`campaign`") знаходяться в розділі `traffic_source`, тому до них звертатися через `traffic_source`. .

2. Далі нам потрібні дані за 2021 рік

	* Це ми можемо зробити через фільтр where та `_table_suffix` between або просто прописати 2021 рік у `from` суфікс.
	
	* Далі обираємо в select `event_date`, `event_timestamp`, `event_name`.
	
	- До фільтру where потрібно включити показ лише відповідних до завдання назв подій у колонці `event_name`. Тобто ми маємо рахувати значення в нашій вибірці відповідно до цих конкретних назв сеансів:
		- `session_start, view_item, add_to_cart, begin_checkout, add_shipping_info, add_payment_info, purchase`
	
	* Потрібно обрати `user_pseudo_id` та через внутрішній підзапитоб'єднати його з `ga_session_id`.
	
	* <font color="#fbd5b5">По суті мета завдання зводиться до того, що ми по відношенню до вказаних вище етапів сесії користувачів та в межах одного календарного року робимо вибірку з тих показників, що в завданні просять вивести в консоль.</font>


#### Блок 3

1. Створи запит для отримання таблиці з інформацією про конверсії від початку сесії до покупки. Таблиця з результатами **має містити такі поля:**

	- event_date — дата старту сесії, що отримана з поля event_timestamp
	- source — джерело відвідування сайту
	- medium — medium відвідування сайту
	- campaign — назва кампанії відвідування сайту
	- user_sessions_count — кількість унікальних сесій в унікальних користувачів у відповідну дату та для відповідного каналу трафіку.
	- visit_to_cart — _конверсія_ від початку сесії на сайті до _додавання товару в корзину_ (у відповідну дату та для відповідного каналу трафіку)
	- visit_to_checkout — конверсія від початку сесії на сайті до _спроби оформити замовлення_ (у відповідну дату та для відповідного каналу трафіку)
	- visit_to_purchase — конверсія від початку сесії на сайті до _покупки_ (у відповідну дату та для відповідного каналу трафіку)
	
	**Примітка** Зверни увагу, що різні користувачі можуть мати однакові ідентифікатори сесій. Тому щоб порахувати унікальні сесії унікальних користувачів, треба враховувати не тільки ідентифікатор сесії, а й ідентифікатор користувача.

**Можливе розв'язання:**

1. "_Створи запит для отримання таблиці з інформацією про конверсії від початку сесії до покупки_". 

	* Як я розумію, нам треба порахувати конверсію між стартом сесії користувача до купівлі ним товару.
	
		* Для початку зроблю вибірку з `event_timestamp, traffic_source.name, traffic_source.medium, traffic_source.source`, об'єднаю `user_pseudo_id` та `ga_session_id`. Для  `event_timestamp` зроблю `timestamp_micros`.
		
		* В завданні йдеться про те, що потрібно робити розрахунки на основі подій `visit_to_cart`, `visit_to_checkout`, `visit_to_purchase`, які знаходяться в колонці `event_name`, тому її також додаємо до вибірки, а в `where` прописуємо відповідні параметри фільтрації подій даної колонки: `'session_start', 'add_to_cart', 'begin_checkout', 'purchase'`.
				~={orange}Примітка:=~ `'session_start'` мусимо додати, адже нам потрібно буде віднімати від нього (від старту сесії) решту подій, щоб отримати конверсію.
		
		* Підсумовуючи 1 частину завдання, ми зробили вибірку, підґрунтям для якої є колонка `event_name` з подіями `'session_start', 'add_to_cart', 'begin_checkout', 'purchase'`, на основі яких ми в подальшому будемо отримувати......... , а також зробили інші вибірки, як от джерела трафіку, звідки прийшли люди, витягли дату й час з колонки `event_timestamp` (яка відповідає за дату й час тієї чи іншої події), поєднали `user_pseudo_id` та `ga_session_id` (щоб у разі однакових користувацьких id, ми мали унікальні сесії по відношенню до однакових `user_pseudo_id`),

	* Друга частина завдання має визначити, скільки унікальних користувачів "було присутньо" на відповідних сесіях. Нам потрібно порахувати цих користувачів по відношенню до колонок traffic та `event_timestamp`. Тут нам допоможе умовний оператор `case`. Як це буде реалізовано:
```SQL 
    count(distinct
                case
                    when event_name = 'session_start'
                    then user_id_and_session_id
                end) as session_start_count,

--- count(distinct означає, що ми порахуємо унікальних користувачів, якщо умова буде відповідати наступному:
--- when event_name = session_start - якщо подія в межах 'session_start', то буде повернено значення із user_id_and_session_id
```

~={orange}Пояснення=~: рахуємо унікальних користувачів лише по відношенню до потрібної події. В підсумку ми отримаємо число унікальних користувачів, які "були" під час потрібних нам сесій. 
- Логіка полягає в тому, що нам не потрібно розбиратися в усьому контексті активності відвідувачів сайту, нам потрібні сухі числа тих унікальних користувачів, які по факту були на потрібних нам сесіях. Так ми відслідковуємо чи "дожили" потенційні клієнти з моменту старту сесії до моменту безпосередньої купівлі якогось товару.
- В кінцевому варіанті ми рахуємо унікальних користувачів у по відношенню до event_timestamp і джерела трафіку. Це дозволяє порівнювати кількість користувачів, які почали сесію, з тими, хто в рамках тієї ж самої групи дійшов до add_to_cart, begin_checkout чи purchase.
* Останнім кроком буде просто зробити фінальну вибірку та прописати ділення подій 'add_to_cart', 'begin_checkout', 'purchase' на 'session_start'.


#### Блок 4
*Порівняння конверсії між різними посадковими сторінками (виконання необовʼязкове, за бажанням)*

Для виконання цієї задачі тобі потрібно буде отримати **page path** (шлях до сторінки без адреси домену та без параметрів посилання) з page_location в події **початку сесії.**

**Для кожного унікального page path початку сесії порахуй такі метрики на основі даних за 2020 рік:**

- Кількість унікальних сесій в унікальних користувачів.
- Кількість покупок.
- Конверсія від початку сесії до покупки.

**Примітка** 
Події старту сесії та покупки можуть мати різні url. Тому злити подію старту сесії з подією покупки можна за ідентифікатором користувача та ідентифікатором сесії.

**На що ментор зверне увагу при перевірці роботи:**

1. Унікальний ідентифікатор сесії — комбінація ідентифікатора користувача та ідентифікатора сесії.
2. Відображено дані за 2020 рік.
3. page path є адресою сторінки з page_location, що відповідає події session_start без зайвих символів.
4. Кількість покупок — кількість унікальних сесій, що мали івент 'purchase’.
5. Результуючі цифри агреговано за page path.


**Можливе розв'язання:**

1. Для початку пояснення *"Скільки унікальних сесій із певної сторінки старту завершилися покупкою?"*.
	
	* Щоб отримати події старту сесії (`session_start`) разом із landing page path, в якості першого етапу, створимо CTE, в якому за основу візьмемо в `where`  значення для `event_name = 'session_start'`, а вже на основі нього зробимо об'єднаний `user_id_and_session_id`, в суфіксі загального `from` оберемо діапазон за 2020 рік та за допомогою regex витягнемо потрібну частину URL (`regexp_extract((select value.string_value from mainquery.event_params where key = 'page_location'), r'https?://[^/]+([^?#]+)' ) as landing_page_path`), де:
	
		* `https?://` - шукаємо `http` або `https` ( `?` - означає "необов'язково").
		
		* `[^/]+` - шукаємо будь-які символи, окрім `/`, дозволяє нам знайти домен.
		
		* `([^?#]+)` - в дужках знаходяться параметри пошуку символів, які ми хочемо витягти. Шукає один або більше (`+`) символів, які не є тим, що записано в квадратних дужках, (`[]`) ні тим, що є знаком питання (`?`), ні хештегом (`#`). Це і є чистий `page path`. Назвемо цю колонку `landing_page_path`.
		* ~={orange}Пояснення:=~ **Посадкова сторінка** - **перша сторінка**, яку бачить користувач, коли заходить на сайт під час конкретної сесії. Виходячи з завдання, нам потрібно порахувати, **яка посадкова сторінка (landing page)** при старті сесії дає **найкращий показник конверсії для покупки**.
	
	* Треба порахувати кількість покупок в кожному `user_id_and_session_id`. Наступним кроком буде знайти усі сесії (`user_id_and_session_id`), в яких відбулася покупка. Ми заново прописуємо та об'єднуємо дві колонки, щоб  отримати `user_id_and_session_id` для його майбутнього поєднання з першим CTE. Прямо зараз ми не зможемо безпосередньо дізнатися кількість покупок, але можемо зробити для цього підґрунтя:
	
		* через `case` задати умову, де `case when event_name = 'purchase' then 1 else 0`. Таким чином по кожному `user_id_and_session_id` буде колонка з 1 або 0 (була купівля цим користувачем, чи ні). Можливі дублікати цих користувачів через різні події в межах їх сесій (через що, власне, рядкові дублікати й виникають), тому потрібно обгорнути цей case в `max`.
			* ~={orange}Пояснення:=~ `max` поверне найбільше значення відносно однієї повної сесії користувача (якщо кілька дублікатів, і всі без покупок - поверне 0, якщо ж в межах якоїсь сесії відбулась подія `'purchase'` - поверне найбільше значення - 1).
    
		- Як і в попередньому CTE, в суфіксі прописуємо, щоб дані були за 2020 рік. Далі фільтруємо дані, залишаючи лише події покупок (`where event_name = 'purchase'`). Групуємо дані за `user_id_and_session_id`.
		
		- Останньою частиною запиту буде розрахунок конверсії, кількість унікальних сесій для кожної посадкової сторінки, об'єднати, прикріпити другу таблицю з покупками:
		
			- Обираємо за джерело попередню CTE, а для повного відображення всіх `user_id_and_session_id`, приєднаємо цю колонку з 1 CTE до 2 CTE за допомогою `join` - він зберігає всі рядки з таблиці 1 CTE (навіть якщо для них не було покупок), що дозволяє нам коректно розрахувати конверсію.
			
			- У вибірці включаємо `landing_page_path` з CTE 1, робимо `count(distinct t1.user_id_and_session_id) as total_sessions`, що виконує першу частину завдання. Рахуємо кількість унікальних користувачів для кожної посадкової сторінки з нашого об'єднаного `user_id_and_session_id`: `count(raw_data_2.user_id_and_session_id) as total_purchases` - рахуємо кількість покупок. `count` тут працює, адже після `JOIN` в цій колонці будуть лише ті значення, для яких була знайдена відповідна покупка - це виконує другу частину завдання.
			
			- Далі, для виконання третьої частини завдання треба поділити кількість покупок на кількість сесій, щоб отримати коефіцієнт конверсії. Це можна зробити за допомогою внутрішньої для BigQuery функції безпечного ділення на 0: `safe_divide(count(raw_data_2.user_id_and_session_id), count(distinct raw_data_1.user_id_and_session_id)) as conversion_rate`.
				- ~={orange}Пояснення: =~`SAFE_DIVIDE` — це функція в BigQuery, яка виконує ділення, але, на відміну від звичайного оператора "`/`", вона спеціально розроблена для безпечної обробки ділення на нуль, де замість помилки вона повертає `NULL`.
			
			- `group by raw_data_1.landing_page_path`: виконує умову 5. Групуємо всі розрахунки за `landing_page_path`. Це дає один рядок з агрегованими даними для кожної унікальної посадкової сторінки.




#### Блок 5

***Для кожної унікальної сесії визнач:***

1. Чи був користувач залучений під час цієї сесії (якщо значення параметру `session_engaged` = ‘1’).
2. Загальний час активності користувача під час сесії (сума параметру `engagement_time_msec` з кожної події сесії).
3. Чи відбулася покупка під час сесії.

***Порахуй значення коефіцієнта кореляції:***

- між п.1 та п.3
- між п.2 та п.3

1. Унікальний ідентифікатор сесії — комбінація ідентифікатора користувача та ідентифікатора сесії.
2. Виконана перевірка на відсутність значень (coalesce) у полі 'engagement_time_msec’.
3. 'session_engaged’ string_value значення переведено в integer.
4. Покупки визначаються подією purchase.
5. У фінальній таблиці є кореляція конверсії у покупку як з часом взаємодії так і з наявністю взаємодії в сесії.

**Можливе розв'язання:**

Що ми маємо знайти за завданням:
* Чи був користувач якісно "залученим"?
* Загальна сума `engagement_time_msec` (загальний час активності користувачів)
* Чи відбулася купівля (`event_name = 'purchase'`)?
* Коефіцієнти кореляції між 1 і 3 - 2 і 3.

1. **В загальному, треба вивести 3 колонки, а вже по них рахувати кореляцію**. Для початку вибираємо їх: `user_id_and_session_id` - компіляція (ставимо її в основу `group by`), `engagement_time_msec` - загальний час на платформі, `session_engaged` - "якісна" залученість.

	~={orange}Пояснення: =~ для розуміння контексту, потрібно розібрати, що таке `session_engaged` та `engagement_time_msec` і чим вони відрізняються. Обидва показники описують активність користувача.
	* `engagement_time_msec` - кількісний показник. Він вимірює, скільки часу (у мілісекундах) користувач провів у взаємодії з сайтом чи додатком. Це може бути, наприклад, 5000 мс, 15000 мс тощо. Цей параметр фіксує тривалість активності користувача для кожної окремої події.

	* `session_engaged`: Це бінарний (якісний) показник. Його значення може бути лише `1` або `0`. Цей параметр вказує, чи відповідала сесія певним критеріям залученості, які встановлює Google Analytics або компанія. Зазвичай це відбувається, якщо сесія триває довше 10 секунд, має конверсійну подію (наприклад, покупку), має 2 чи більше переглядів сторінок.

	* Основна відмінність: `engagement_time_msec` — це **фактичний час**, тоді як `session_engaged` — це **статус сесії** ("так, людина була залученою" або "ні, не була"), який вставлюється на основі інших умов, зокрема й часу взаємодії.

2. **Наступний крок: виконуємо _"Чи був користувач залучений під час сесії"_ та _"Загальний час активності користувача під час сесії"_. Після вибірки 3 колонок, маємо провести певні дії з ними:**

	* `engagement_time_msec`. Оскільки ми зрозуміли, що йдеться про всю сесію, а не окремі її події, для виконання цього завдання раніше витягнутий `engagement_time_msec` **потрібно сумувати**, щоб отримати увесь загальний час сесії по відношенню до `user_id_and_session_id`, отже, прописуємо до нього `sum`.
		* ~={orange}Пояснення:=~ Коли в завданні йдеться про **сесію**, мається на увазі **вся сесія конкретного користувача** (це є наш об'єднаний `user_id_and_session_id`), а окремі події, як `session_start', 'add_to_cart', 'begin_checkout', 'purchase'` тощо, в сукупності складають повноцінну сесію.
		* ~={orange}Пояснення: =~ Чому ми сумуємо `engagement_time_msec`?
		 `engagement_time_msec` – це параметр, який фіксує тривалість активності користувача **для кожної окремої події**. Коли користувач взаємодіє з сайтом чи додатком, ініціюється багато подій. Кожна з цих подій має свій параметр `engagement_time_msec`, який вимірює, скільки часу минуло між цією подією та наступною. Щоб визначити **загальний час активності за всю сесію**, потрібно **підсумувати** ці всі частини часу відносно всіх подій, що відбулися в межах однієї сесії.
	
	* Щодо `session_engaged`, то, як вже згадувалося, цей параметр відповідає за якісний показник залучення, який закладає google або компанія. Нам потрібно вивести цей показник. 
		* ~={orange}Пояснення:=~ Дилема в тому, що цей показник залученості перебуває не тільки всередині колонки `value.int_value`, а й всередині `value.string_value`, тобто `session_engaged` може бути або `int_value`, або `string_value`, тому:
		    - пишемо код для витягнення як `value.int_value`, так і `value.string_value`;
		    - якщо при перевірці `value.int_value` показник (1 або 0) не знайдеться, пошук переходитиме до даних в `value.string_value`. Далі пробуємо перетворити `string_value` на `int` через `safe_cast`, який, в разі перевірки якихось некоректних даних (наприклад, рядок `"abcd"` замість `"1"`), просто поверне `NULL`;
			- якщо й там нічого - буде 0.
	
	    - Частина `(select value.int_value from mainquery.event_params where key = 'session_engaged')` шукає в кожній події параметр із ключем `session_engaged`. Якщо він існує, повертається його значення (`1`). В іншому випадку — `NULL`.
	    
	    - ~={orange}Пояснення: =~ При виведенні в консоль всіх вище написаних показників, може виникнути проблема в `user_id_and_session_id` та `session_engaged`, *в двох рядках чомусь дві однакові* `user_id_and_session_id`: один із залученням (1), інший ні (0).
		* **Чому такі дублі? Тому що:**
			- Усі вони мають один і той самий `user_id_and_session_id`
		    - Але це виводяться **різні події** з різним набором `event_params`
			- Тільки деякі з них мають параметр `session_engaged = 1`
			- Або лише одна має `event_name = 'purchase'`
		- **Що треба зробити?** Для кожного `user_id_and_session_id` агрегувати все:
		    - `MAX(session_engaged)` - чи була залученість?
		    - `SUM(engagement_time_msec)` - скільки часу користувач був активним?
		    - `MAX(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END)` - чи була купівля?
		* **І тому не проблема, що `user_id_and_session_id` повторюється.**
	    - Саме тому `GROUP BY user_id_and_session_id` є критично важливим - ми збираємо всі події сесії в одне.
	    - І саме тому `MAX(...)` і `SUM(...)` працюють - вони обчислюють по групі.
	
	- Розуміючи вище написане, нам потрібно витягти "залученість" із сесій, де зустрічаються значення як 1, так і 0 по відношенню до `user_id_and_session_id` та `session_engaged`. Тут нам допоможе функція `max`. 
		- Знову ж таки, через ці "дублі" ми отримуємо по кілька однакових комбінацій `user_id_and_session_id` та `session_engaged`; використання функції `max` дозволить обрати тільки найбільший показник по відношенню до цих комбінацій. Функція перевірить однакові рядки `user_id_and_session_id`, і в разі обох значень (0 або 1), поверне найбільше - 1.
		- ~={orange}Пояснення:=~ так наочно виглядають дублікати одних і тих же комбінацій.
			 ![[Pasted image 20250803144303.png]]

	* Далі ***"Чи відбулася покупка під час сесії"***. Нам треба визначити, була купівля чогось, чи ні. Для цього ми виведемо незалежну колонку параметром якої буде `event_name`; помістимо її в `case` з умовою, що в цій `event_name` подія має дорівнювати `'purchase'`, тобто `when event_name = 'purchase'`. Якщо так, то по відношенню до кожного згрупованого `user_id_and_session_id`, ми отримаємо значення "0" (не було купівлі) або "1" (була купівля); назвемо цю колонку як `purchase_checking`.
	
	* Наступним кроком буде використати функцію `coalesce` до `engagement_time_msec` та обох `session_engaged` (де `string_value` та `int_value`). Це робиться для коректного розрахунку майбутньої кореляції. 
		* ~={orange}Пояснення:=~ тут важливо звернути увагу на обидва `session_engaged`: для для коректного функціонування даної частини коду (коли спочатку перевіряється `int_value`, знаходить або не знаходить 0 або 1, а затим береться за `string_value`, повторює дію), coalesce потрібно прописати двічі, один для `int_value`, інший для `string_value`: 
			* ![[Pasted image 20250804112553.png]]
	* Останній крок. ***"Порахуй значення коефіцієнта кореляції"***. Робимо з вище написаного CTE, затим звертаємося до нього, прописуючи дві функції `corr`, в одну ставимо порівняння між `engagement_time_msec` та `purchase_checking`, в іншу - `session_engaged`, `purchase_checking` для визначення кореляції.
	
	* ~={yellow}Зробивши ці дії, ми виконаємо всі частини завдання:=~
		1. _"Чи був користувач залучений під час сесії"_
		2. *"Загальний час активності користувача під час сесії"*
		3. *"Чи відбулася покупка під час сесії"*
		4. *"Порахуй значення коефіцієнта кореляції"*

	
	
	





